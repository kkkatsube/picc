# Canvas画像配置エディタ 機能仕様書

## 概要
SVGキャンバス上に複数の画像を配置・編集し、フルスクリーン表示できる機能のLaravel + React移行仕様書。
マウス操作とキーボードショートカットによる直感的な画像配置・クロッピング機能を提供する。

---

## 1. 機能概要

### 1.1 主要機能
| 機能 | 説明 |
|------|------|
| SVGキャンバス描画 | 指定サイズのSVGキャンバス上に画像を配置 |
| ドラッグ&ドロップ | マウスで画像を自由に移動 |
| 画像クロッピング | キーボード操作で画像の表示範囲を調整 |
| 画像サイズ調整 | キーボード操作で表示倍率を変更 |
| フルスクリーン表示 | 1:1スケールでの全画面表示 |
| 動的スケール調整 | 編集モードでの画面サイズに応じた自動スケール |
| 画像追加 | URL指定で画像をキャンバスに追加 |
| 画像削除 | 選択中の画像を削除 |
| 一括保存 | 全画像の配置情報をサーバーに保存 |

---

## 2. UI構成

### 2.1 レイアウト構造

```
┌─────────────────────────────────────────────────────────┐
│ Header (App Bar)                                        │
├──────────────────────────┬──────────────────────────────┤
│                          │  Add Picture                 │
│  Canvas Editor           │  ┌────────────────────────┐  │
│  ┌────────────────────┐  │  │ Picture URL Input      │  │
│  │                    │  │  │ [Submit Button]        │  │
│  │  SVG Canvas        │  │  └────────────────────────┘  │
│  │  (Image Layer)     │  │                              │
│  │                    │  │  Picture List                │
│  │                    │  │  ┌────────────────────────┐  │
│  └────────────────────┘  │  │ (Under Construction)   │  │
│                          │  └────────────────────────┘  │
└──────────────────────────┴──────────────────────────────┘
│ Footer                                                  │
└─────────────────────────────────────────────────────────┘
```

### 2.2 Canvas Editor詳細

**編集モード（通常表示）**
- キャンバスサイズ: `canvas.width * scale` × `canvas.height * scale`
- スケール計算: ウィンドウサイズに応じて動的調整（0.1 ~ 1.0）
- 背景: 白 + 黒枠線

**フルスクリーンモード**
- キャンバスサイズ: `canvas.width` × `canvas.height`（1:1スケール）
- 全画面表示（ブラウザFullscreen API使用）
- ESCキーで解除可能

---

## 3. データ構造

### 3.1 Canvas State

```typescript
interface CanvasState {
  picboard_id: number;
  screen_width: number;  // キャンバス幅
  screen_height: number; // キャンバス高さ
  images: ImageData[];
  scale: number;         // 現在の表示スケール（0.1 ~ 1.0）
  fsflg: boolean;        // フルスクリーンフラグ
}
```

### 3.2 ImageData Structure

```typescript
interface ImageData {
  id: number;
  canvas_id: number;
  uri: string;           // 画像URL
  x: number;             // キャンバス上のX座標
  y: number;             // キャンバス上のY座標
  width: number;         // 画像の元幅
  height: number;        // 画像の元高さ
  size: number;          // 表示倍率（デフォルト: 0.25）
  left: number;          // 左クロッピングオフセット
  right: number;         // 右クロッピングオフセット
  top: number;           // 上クロッピングオフセット
  bottom: number;        // 下クロッピングオフセット
}
```

### 3.3 Drag State

```typescript
interface DragState {
  isMove: boolean;       // ドラッグ中フラグ
  target: number;        // 選択中の画像インデックス
  beforeMouseX: number | null;
  beforeMouseY: number | null;
}
```

---

## 4. 画像描画ロジック

### 4.1 SVG clipPath による画像クロッピング

**計算式**:
```javascript
// クリッピング領域の定義
clipPath = {
  x: (image.x + (image.left * image.size)) * currentScale,
  y: (image.y + (image.top * image.size)) * currentScale,
  width: (image.width - image.left - image.right) * image.size * currentScale,
  height: (image.height - image.top - image.bottom) * image.size * currentScale
}

// 画像の描画位置・サイズ
image_render = {
  x: image.x * currentScale,
  y: image.y * currentScale,
  width: image.width * image.size * currentScale,
  height: image.height * image.size * currentScale
}
```

**React実装例**:
```jsx
<svg width={svgWidth} height={svgHeight}>
  {images.map((image) => (
    <g key={image.id}>
      <clipPath id={`clip-${image.id}`}>
        <rect
          x={(image.x + image.left * image.size) * currentScale}
          y={(image.y + image.top * image.size) * currentScale}
          width={(image.width - image.left - image.right) * image.size * currentScale}
          height={(image.height - image.top - image.bottom) * image.size * currentScale}
        />
      </clipPath>
      <image
        href={image.uri}
        x={image.x * currentScale}
        y={image.y * currentScale}
        width={image.width * image.size * currentScale}
        height={image.height * image.size * currentScale}
        clipPath={`url(#clip-${image.id})`}
        onMouseDown={(e) => handleMouseDown(e, index)}
        style={{ cursor: 'move' }}
      />
    </g>
  ))}
</svg>
```

### 4.2 スケール計算ロジック

**動的スケール計算**:
```javascript
function calculateOptimalScale(canvasWidth, canvasHeight) {
  const availableWidth = Math.max(800, window.innerWidth * 0.6);
  const availableHeight = Math.max(500, window.innerHeight * 0.7);

  const scaleX = availableWidth / canvasWidth;
  const scaleY = availableHeight / canvasHeight;

  const optimalScale = Math.min(scaleX, scaleY);
  return Math.max(0.1, Math.min(1.0, optimalScale));
}
```

**currentScale計算**:
```javascript
const currentScale = fsflg ? 1.0 : scale;
```

---

## 5. インタラクション仕様

### 5.1 マウス操作

#### ドラッグ&ドロップ

**イベントフロー**:
1. `mousedown` on image → ドラッグ開始、対象画像インデックスを記録
2. `mousemove` on document → 画像位置を更新
3. `mouseup` on document → ドラッグ終了

**位置計算**:
```javascript
function handleMouseMove(e) {
  if (!isMove) return;

  // スケールを考慮したマウス座標
  const mouseX = e.offsetX / currentScale;
  const mouseY = e.offsetY / currentScale;

  // 前回位置との差分計算
  const dx = mouseX - beforeMouseX;
  const dy = mouseY - beforeMouseY;

  // 画像位置を更新
  images[target].x += dx;
  images[target].y += dy;

  // 現在位置を記録
  beforeMouseX = mouseX;
  beforeMouseY = mouseY;
}
```

### 5.2 キーボード操作

| キー | keyCode | 機能 | 変更内容 |
|------|---------|------|----------|
| `<` | 188 | 左クロッピング拡大 | `left++` |
| `>` | 190 | 右クロッピング拡大 | `right++` |
| `M` | 77 | 左クロッピング縮小 | `left--` |
| `?` | 191 | 右クロッピング縮小 | `right--` |
| `(` | 56 | 上クロッピング拡大 | `top++` |
| `)` | 57 | 下クロッピング拡大 | `bottom++` |
| `'` | 55 | 上クロッピング縮小 | `top--` |
| `0` | 48 | 下クロッピング縮小 | `bottom--` |
| `+` | 186 | サイズ拡大 | `size += 0.01` |
| `-` | 189 | サイズ縮小 | `size -= 0.01` |
| `S` | 83 | 全画像保存 | APIリクエスト送信 |
| `1` | 49 | フルスクリーン切替 | Fullscreen API呼び出し |
| `D` | 68 | 画像削除 | DELETE APIリクエスト |

**React実装例**:
```javascript
useEffect(() => {
  const handleKeyDown = (e) => {
    if (!images[target]) return;

    switch(e.keyCode) {
      case 188: // <
        setImages(prev => {
          const updated = [...prev];
          updated[target].left++;
          return updated;
        });
        break;
      case 190: // >
        setImages(prev => {
          const updated = [...prev];
          updated[target].right++;
          return updated;
        });
        break;
      // ... 他のキー処理
      case 83: // S
        handleSave();
        break;
      case 49: // 1
        if (!fsflg) {
          canvasRef.current.requestFullscreen();
          setFsflg(true);
        }
        break;
    }
  };

  document.addEventListener('keydown', handleKeyDown);
  return () => document.removeEventListener('keydown', handleKeyDown);
}, [images, target, fsflg]);
```

---

## 6. API仕様

### 6.1 Canvas取得

**Endpoint**: `GET /api/canvases/{id}`

**Response**:
```json
{
  "id": 1,
  "user_id": 1,
  "name": "My Canvas",
  "memo": "Description",
  "width": 1920,
  "height": 1080,
  "images": [
    {
      "id": 1,
      "canvas_id": 1,
      "uri": "https://example.com/image.jpg",
      "x": 100,
      "y": 200,
      "width": 800,
      "height": 600,
      "size": 0.5,
      "left": 0,
      "right": 0,
      "top": 0,
      "bottom": 0,
      "created_at": "2024-01-01T00:00:00Z",
      "updated_at": "2024-01-01T00:00:00Z"
    }
  ],
  "created_at": "2024-01-01T00:00:00Z",
  "updated_at": "2024-01-01T00:00:00Z"
}
```

### 6.2 画像位置更新

**Endpoint**: `PUT /api/canvas-images/{id}`

**Request Body**:
```json
{
  "x": 150,
  "y": 250,
  "width": 800,
  "height": 600,
  "size": 0.6,
  "left": 10,
  "right": 5,
  "top": 20,
  "bottom": 15
}
```

**Response**:
```json
{
  "id": 1,
  "canvas_id": 1,
  "uri": "https://example.com/image.jpg",
  "x": 150,
  "y": 250,
  "width": 800,
  "height": 600,
  "size": 0.6,
  "left": 10,
  "right": 5,
  "top": 20,
  "bottom": 15,
  "updated_at": "2024-01-01T01:00:00Z"
}
```

### 6.3 画像追加

**Endpoint**: `POST /api/canvases/{id}/images`

**Request Body (multipart/form-data)**:
```json
{
  "add_picture_url": "https://example.com/newimage.jpg"
}
```

**処理フロー**:
1. 指定URLから画像をダウンロード
2. MiniMagick等で画像サイズ（width, height）を取得
3. 初期配置データを生成:
   ```json
   {
     "canvas_id": 1,
     "uri": "https://example.com/newimage.jpg",
     "x": 0,
     "y": 0,
     "width": 1200,  // 取得した実寸
     "height": 800,  // 取得した実寸
     "size": 0.25,   // デフォルト倍率
     "left": 0,
     "right": 0,
     "top": 0,
     "bottom": 0
   }
   ```
4. データベースに保存

**Response**:
```json
{
  "id": 2,
  "canvas_id": 1,
  "uri": "https://example.com/newimage.jpg",
  "x": 0,
  "y": 0,
  "width": 1200,
  "height": 800,
  "size": 0.25,
  "left": 0,
  "right": 0,
  "top": 0,
  "bottom": 0,
  "created_at": "2024-01-01T02:00:00Z",
  "updated_at": "2024-01-01T02:00:00Z"
}
```

### 6.4 画像削除

**Endpoint**: `DELETE /api/canvas-images/{id}`

**Response**:
```json
{
  "status": "success",
  "message": "Image deleted"
}
```

### 6.5 一括保存処理

**クライアント側実装**:
```javascript
async function saveAllImages(images) {
  const promises = images.map(image =>
    axios.put(`/api/canvas-images/${image.id}`, {
      x: image.x,
      y: image.y,
      width: image.width,
      height: image.height,
      size: image.size,
      left: image.left,
      right: image.right,
      top: image.top,
      bottom: image.bottom
    })
  );

  try {
    await Promise.all(promises);
    console.log('Save: success');
  } catch (error) {
    console.error('Save: failure', error);
  }
}
```

---

## 7. Laravel Controller実装例

### 7.1 CanvasController.php

```php
<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Models\Canvas;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

class CanvasController extends Controller
{
    /**
     * キャンバス詳細取得（画像含む）
     */
    public function show($id)
    {
        $canvas = Canvas::with('images')
            ->where('id', $id)
            ->where('user_id', Auth::id())
            ->firstOrFail();

        return response()->json($canvas);
    }

    /**
     * キャンバス作成
     */
    public function store(Request $request)
    {
        $validated = $request->validate([
            'name' => 'nullable|string|max:255',
            'memo' => 'nullable|string',
            'width' => 'required|integer|min:1',
            'height' => 'required|integer|min:1',
        ]);

        $canvas = Canvas::create([
            'user_id' => Auth::id(),
            'name' => $validated['name'],
            'memo' => $validated['memo'],
            'width' => $validated['width'],
            'height' => $validated['height'],
        ]);

        return response()->json($canvas->load('images'), 201);
    }
}
```

### 7.2 CanvasImageController.php

```php
<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Models\Canvas;
use App\Models\CanvasImage;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Http;
use Intervention\Image\Facades\Image;

class CanvasImageController extends Controller
{
    /**
     * 画像位置更新
     */
    public function update(Request $request, $id)
    {
        $image = CanvasImage::findOrFail($id);

        // 認証チェック
        $canvas = Canvas::where('id', $image->canvas_id)
            ->where('user_id', Auth::id())
            ->firstOrFail();

        $validated = $request->validate([
            'x' => 'nullable|integer',
            'y' => 'nullable|integer',
            'width' => 'nullable|integer',
            'height' => 'nullable|integer',
            'size' => 'nullable|numeric|min:0.01|max:10',
            'left' => 'nullable|integer|min:0',
            'right' => 'nullable|integer|min:0',
            'top' => 'nullable|integer|min:0',
            'bottom' => 'nullable|integer|min:0',
        ]);

        $image->update($validated);

        return response()->json($image);
    }

    /**
     * 画像追加（URL指定）
     */
    public function store(Request $request, $canvasId)
    {
        $canvas = Canvas::where('id', $canvasId)
            ->where('user_id', Auth::id())
            ->firstOrFail();

        $validated = $request->validate([
            'add_picture_url' => 'required|url',
        ]);

        $imageUrl = $validated['add_picture_url'];

        try {
            // 画像ダウンロード
            $response = Http::timeout(10)->get($imageUrl);

            if (!$response->successful()) {
                return response()->json([
                    'error' => 'Failed to fetch image'
                ], 400);
            }

            // 画像サイズ取得（Intervention Image使用）
            $img = Image::make($response->body());

            // 画像レコード作成
            $canvasImage = CanvasImage::create([
                'canvas_id' => $canvas->id,
                'uri' => $imageUrl,
                'x' => 0,
                'y' => 0,
                'width' => $img->width(),
                'height' => $img->height(),
                'size' => 0.25,
                'left' => 0,
                'right' => 0,
                'top' => 0,
                'bottom' => 0,
            ]);

            return response()->json($canvasImage, 201);

        } catch (\Exception $e) {
            return response()->json([
                'error' => 'Failed to process image',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * 画像削除
     */
    public function destroy($id)
    {
        $image = CanvasImage::findOrFail($id);

        // 認証チェック
        $canvas = Canvas::where('id', $image->canvas_id)
            ->where('user_id', Auth::id())
            ->firstOrFail();

        $image->delete();

        return response()->json([
            'status' => 'success',
            'message' => 'Image deleted'
        ]);
    }
}
```

---

## 8. React Component構成例

### 8.1 Component階層

```
CanvasEditorPage
├── CanvasToolbar (保存ボタン、フルスクリーンボタン等)
├── CanvasViewer
│   └── SVGCanvas
│       └── CanvasImage (複数)
└── ImageControls
    ├── AddImageForm
    └── ImageList
```

### 8.2 主要Component実装例

#### CanvasEditorPage.tsx

```typescript
import React, { useState, useEffect, useRef } from 'react';
import axios from 'axios';

interface CanvasEditorPageProps {
  canvasId: number;
}

const CanvasEditorPage: React.FC<CanvasEditorPageProps> = ({ canvasId }) => {
  const [canvas, setCanvas] = useState(null);
  const [images, setImages] = useState([]);
  const [scale, setScale] = useState(0.5);
  const [fsflg, setFsflg] = useState(false);
  const [target, setTarget] = useState(0);
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

  const canvasRef = useRef(null);

  const currentScale = fsflg ? 1.0 : scale;

  // 初期データ取得
  useEffect(() => {
    axios.get(`/api/canvases/${canvasId}`)
      .then(response => {
        setCanvas(response.data);
        setImages(response.data.images);
        updateScale(response.data.width, response.data.height);
      });
  }, [canvasId]);

  // スケール計算
  const updateScale = (width, height) => {
    if (fsflg) return;

    const availableWidth = Math.max(800, window.innerWidth * 0.6);
    const availableHeight = Math.max(500, window.innerHeight * 0.7);

    const scaleX = availableWidth / width;
    const scaleY = availableHeight / height;

    const optimalScale = Math.min(scaleX, scaleY);
    setScale(Math.max(0.1, Math.min(1.0, optimalScale)));
  };

  // ドラッグ開始
  const handleMouseDown = (e, index) => {
    setIsDragging(true);
    setTarget(index);
    setDragStart({
      x: e.nativeEvent.offsetX / currentScale,
      y: e.nativeEvent.offsetY / currentScale
    });
  };

  // ドラッグ中
  const handleMouseMove = (e) => {
    if (!isDragging) return;

    const mouseX = e.nativeEvent.offsetX / currentScale;
    const mouseY = e.nativeEvent.offsetY / currentScale;

    const dx = mouseX - dragStart.x;
    const dy = mouseY - dragStart.y;

    setImages(prev => {
      const updated = [...prev];
      updated[target] = {
        ...updated[target],
        x: updated[target].x + dx,
        y: updated[target].y + dy
      };
      return updated;
    });

    setDragStart({ x: mouseX, y: mouseY });
  };

  // ドラッグ終了
  const handleMouseUp = () => {
    setIsDragging(false);
  };

  // 保存
  const handleSave = async () => {
    const promises = images.map(image =>
      axios.put(`/api/canvas-images/${image.id}`, {
        x: image.x,
        y: image.y,
        size: image.size,
        left: image.left,
        right: image.right,
        top: image.top,
        bottom: image.bottom
      })
    );

    try {
      await Promise.all(promises);
      console.log('Save: success');
    } catch (error) {
      console.error('Save: failure', error);
    }
  };

  // キーボード操作
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (!images[target]) return;

      switch(e.keyCode) {
        case 188: // <
          setImages(prev => {
            const updated = [...prev];
            updated[target].left++;
            return updated;
          });
          break;
        case 190: // >
          setImages(prev => {
            const updated = [...prev];
            updated[target].right++;
            return updated;
          });
          break;
        case 83: // S
          handleSave();
          break;
        case 49: // 1
          if (!fsflg && canvasRef.current) {
            canvasRef.current.requestFullscreen();
            setFsflg(true);
          }
          break;
        // ... 他のキー処理
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [images, target, fsflg]);

  // フルスクリーン変更検知
  useEffect(() => {
    const handleFullscreenChange = () => {
      if (!document.fullscreenElement) {
        setFsflg(false);
        if (canvas) {
          updateScale(canvas.width, canvas.height);
        }
      }
    };

    document.addEventListener('fullscreenchange', handleFullscreenChange);
    return () => document.removeEventListener('fullscreenchange', handleFullscreenChange);
  }, [canvas]);

  if (!canvas) return <div>Loading...</div>;

  return (
    <div>
      <div
        ref={canvasRef}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
      >
        <svg
          width={canvas.width * currentScale}
          height={canvas.height * currentScale}
          style={{ border: '1px solid black' }}
        >
          {images.map((image, index) => (
            <g key={image.id}>
              <clipPath id={`clip-${image.id}`}>
                <rect
                  x={(image.x + image.left * image.size) * currentScale}
                  y={(image.y + image.top * image.size) * currentScale}
                  width={(image.width - image.left - image.right) * image.size * currentScale}
                  height={(image.height - image.top - image.bottom) * image.size * currentScale}
                />
              </clipPath>
              <image
                href={image.uri}
                x={image.x * currentScale}
                y={image.y * currentScale}
                width={image.width * image.size * currentScale}
                height={image.height * image.size * currentScale}
                clipPath={`url(#clip-${image.id})`}
                onMouseDown={(e) => handleMouseDown(e, index)}
                style={{ cursor: 'move' }}
              />
            </g>
          ))}
        </svg>
      </div>
    </div>
  );
};

export default CanvasEditorPage;
```

---

## 9. 必要なLaravelパッケージ

### 9.1 画像処理

```bash
composer require intervention/image
```

**用途**: 画像URL取得時のサイズ情報取得

**config/app.php設定**:
```php
'providers' => [
    Intervention\Image\ImageServiceProvider::class,
],
'aliases' => [
    'Image' => Intervention\Image\Facades\Image::class,
],
```

### 9.2 HTTP Client

Laravel標準のHTTPクライアント（`Illuminate\Support\Facades\Http`）を使用

---

## 10. 移行チェックリスト

### 10.1 バックエンド実装
- [ ] Canvasモデル・マイグレーション作成
- [ ] CanvasImageモデル・マイグレーション作成
- [ ] CanvasController実装
- [ ] CanvasImageController実装
- [ ] ルート定義（API routes）
- [ ] Intervention Image設定
- [ ] 認証ミドルウェア適用

### 10.2 フロントエンド実装
- [ ] React TypeScript環境構築
- [ ] CanvasEditorPage コンポーネント作成
- [ ] SVG描画ロジック実装
- [ ] ドラッグ&ドロップ機能実装
- [ ] キーボードショートカット実装
- [ ] フルスクリーンAPI統合
- [ ] 動的スケール調整実装
- [ ] 画像追加フォーム実装
- [ ] 一括保存機能実装
- [ ] 画像削除機能実装

### 10.3 テスト
- [ ] API単体テスト
- [ ] ドラッグ操作テスト
- [ ] キーボード操作テスト
- [ ] フルスクリーン切替テスト
- [ ] スケール計算テスト
- [ ] 画像追加・削除テスト

---

## 11. 技術的注意点

### 11.1 CORS設定
外部画像URLを扱う場合、CORS設定が必要な場合があります。

**config/cors.php**:
```php
'paths' => ['api/*'],
'allowed_methods' => ['*'],
'allowed_origins' => ['*'], // 本番環境では適切に制限
'allowed_headers' => ['*'],
'exposed_headers' => [],
'max_age' => 0,
'supports_credentials' => false,
```

### 11.2 画像URL検証
外部URLからの画像取得時、セキュリティリスクを考慮:
- URLホワイトリスト検証
- ファイルサイズ制限
- タイムアウト設定
- MIMEタイプ検証

### 11.3 パフォーマンス最適化
- 画像数が多い場合の仮想スクロール検討
- 保存APIの並列リクエスト制限（最大同時接続数）
- debounce処理による頻繁な更新の抑制

### 11.4 ブラウザ互換性
- Fullscreen API対応状況確認（Safari等）
- SVG clipPath対応確認
- pointer-events対応確認

---

この仕様書に基づいて実装すれば、現行PicboardのCanvas Editor機能をLaravel + React環境に完全移植できます。
